"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

scalar Bytes

type CollateralToken {
  """
  collateral token address
  """
  id: ID!

  """
  is collateral allowed
  """
  allowed: Boolean!
}

input CollateralToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  allowed: Boolean
  allowed_not: Boolean
  allowed_in: [Boolean!]
  allowed_not_in: [Boolean!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [CollateralToken_filter]
  or: [CollateralToken_filter]
}

enum CollateralToken_orderBy {
  id
  allowed
}

type LongShortToken {
  """
  token address
  """
  id: ID!

  """
  the market this token is traded for
  """
  market: Market!
}

input LongShortToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LongShortToken_filter]
  or: [LongShortToken_filter]
}

enum LongShortToken_orderBy {
  id
  market
  market__id
  market__floorLongPayout
  market__ceilingLongPayout
  market__floorValuation
  market__ceilingValuation
  market__expiryTime
  market__createdAtTimestamp
  market__createdAtBlockNumber
}

type Market {
  """
  market contract address
  """
  id: ID!

  """
  long token
  """
  longToken: LongShortToken!

  """
  short token
  """
  shortToken: LongShortToken!

  """
  floor long payout
  """
  floorLongPayout: BigInt!

  """
  ceiling long payout
  """
  ceilingLongPayout: BigInt!

  """
  floor valuation
  """
  floorValuation: BigInt!

  """
  ceiling valuation
  """
  ceilingValuation: BigInt!

  """
  market expiry time
  """
  expiryTime: BigInt!

  """
  when market was created
  """
  createdAtTimestamp: BigInt!

  """
  at which block was market created
  """
  createdAtBlockNumber: BigInt!
}

input Market_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  longToken: String
  longToken_not: String
  longToken_gt: String
  longToken_lt: String
  longToken_gte: String
  longToken_lte: String
  longToken_in: [String!]
  longToken_not_in: [String!]
  longToken_contains: String
  longToken_contains_nocase: String
  longToken_not_contains: String
  longToken_not_contains_nocase: String
  longToken_starts_with: String
  longToken_starts_with_nocase: String
  longToken_not_starts_with: String
  longToken_not_starts_with_nocase: String
  longToken_ends_with: String
  longToken_ends_with_nocase: String
  longToken_not_ends_with: String
  longToken_not_ends_with_nocase: String
  longToken_: LongShortToken_filter
  shortToken: String
  shortToken_not: String
  shortToken_gt: String
  shortToken_lt: String
  shortToken_gte: String
  shortToken_lte: String
  shortToken_in: [String!]
  shortToken_not_in: [String!]
  shortToken_contains: String
  shortToken_contains_nocase: String
  shortToken_not_contains: String
  shortToken_not_contains_nocase: String
  shortToken_starts_with: String
  shortToken_starts_with_nocase: String
  shortToken_not_starts_with: String
  shortToken_not_starts_with_nocase: String
  shortToken_ends_with: String
  shortToken_ends_with_nocase: String
  shortToken_not_ends_with: String
  shortToken_not_ends_with_nocase: String
  shortToken_: LongShortToken_filter
  floorLongPayout: BigInt
  floorLongPayout_not: BigInt
  floorLongPayout_gt: BigInt
  floorLongPayout_lt: BigInt
  floorLongPayout_gte: BigInt
  floorLongPayout_lte: BigInt
  floorLongPayout_in: [BigInt!]
  floorLongPayout_not_in: [BigInt!]
  ceilingLongPayout: BigInt
  ceilingLongPayout_not: BigInt
  ceilingLongPayout_gt: BigInt
  ceilingLongPayout_lt: BigInt
  ceilingLongPayout_gte: BigInt
  ceilingLongPayout_lte: BigInt
  ceilingLongPayout_in: [BigInt!]
  ceilingLongPayout_not_in: [BigInt!]
  floorValuation: BigInt
  floorValuation_not: BigInt
  floorValuation_gt: BigInt
  floorValuation_lt: BigInt
  floorValuation_gte: BigInt
  floorValuation_lte: BigInt
  floorValuation_in: [BigInt!]
  floorValuation_not_in: [BigInt!]
  ceilingValuation: BigInt
  ceilingValuation_not: BigInt
  ceilingValuation_gt: BigInt
  ceilingValuation_lt: BigInt
  ceilingValuation_gte: BigInt
  ceilingValuation_lte: BigInt
  ceilingValuation_in: [BigInt!]
  ceilingValuation_not_in: [BigInt!]
  expiryTime: BigInt
  expiryTime_not: BigInt
  expiryTime_gt: BigInt
  expiryTime_lt: BigInt
  expiryTime_gte: BigInt
  expiryTime_lte: BigInt
  expiryTime_in: [BigInt!]
  expiryTime_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Market_filter]
  or: [Market_filter]
}

enum Market_orderBy {
  id
  longToken
  longToken__id
  shortToken
  shortToken__id
  floorLongPayout
  ceilingLongPayout
  floorValuation
  ceilingValuation
  expiryTime
  createdAtTimestamp
  createdAtBlockNumber
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  """
  pool contract address
  """
  id: ID!

  """
  address of token0
  """
  token0: Token!

  """
  address of token1
  """
  token1: Token!

  """
  long/short token of this pool
  """
  longShortToken: LongShortToken!

  """
  collateral token of this pool
  """
  collateralToken: CollateralToken!

  """
  0 or 1
  """
  collateralTokenPosition: BigInt!

  """
  token0 per token1
  """
  token0Price: BigDecimal!

  """
  token1 per token0
  """
  token1Price: BigDecimal!

  """
  The sqrt(price) of the pool as a Q64.96
  """
  sqrtPriceX96: BigInt!

  """
  pool creation time
  """
  createdAtTimestamp: BigInt!

  """
  at which block was pool created
  """
  createdAtBlockNumber: BigInt!
}

input Pool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_: Token_filter
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_: Token_filter
  longShortToken: String
  longShortToken_not: String
  longShortToken_gt: String
  longShortToken_lt: String
  longShortToken_gte: String
  longShortToken_lte: String
  longShortToken_in: [String!]
  longShortToken_not_in: [String!]
  longShortToken_contains: String
  longShortToken_contains_nocase: String
  longShortToken_not_contains: String
  longShortToken_not_contains_nocase: String
  longShortToken_starts_with: String
  longShortToken_starts_with_nocase: String
  longShortToken_not_starts_with: String
  longShortToken_not_starts_with_nocase: String
  longShortToken_ends_with: String
  longShortToken_ends_with_nocase: String
  longShortToken_not_ends_with: String
  longShortToken_not_ends_with_nocase: String
  longShortToken_: LongShortToken_filter
  collateralToken: String
  collateralToken_not: String
  collateralToken_gt: String
  collateralToken_lt: String
  collateralToken_gte: String
  collateralToken_lte: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_contains_nocase: String
  collateralToken_not_contains: String
  collateralToken_not_contains_nocase: String
  collateralToken_starts_with: String
  collateralToken_starts_with_nocase: String
  collateralToken_not_starts_with: String
  collateralToken_not_starts_with_nocase: String
  collateralToken_ends_with: String
  collateralToken_ends_with_nocase: String
  collateralToken_not_ends_with: String
  collateralToken_not_ends_with_nocase: String
  collateralToken_: CollateralToken_filter
  collateralTokenPosition: BigInt
  collateralTokenPosition_not: BigInt
  collateralTokenPosition_gt: BigInt
  collateralTokenPosition_lt: BigInt
  collateralTokenPosition_gte: BigInt
  collateralTokenPosition_lte: BigInt
  collateralTokenPosition_in: [BigInt!]
  collateralTokenPosition_not_in: [BigInt!]
  token0Price: BigDecimal
  token0Price_not: BigDecimal
  token0Price_gt: BigDecimal
  token0Price_lt: BigDecimal
  token0Price_gte: BigDecimal
  token0Price_lte: BigDecimal
  token0Price_in: [BigDecimal!]
  token0Price_not_in: [BigDecimal!]
  token1Price: BigDecimal
  token1Price_not: BigDecimal
  token1Price_gt: BigDecimal
  token1Price_lt: BigDecimal
  token1Price_gte: BigDecimal
  token1Price_lte: BigDecimal
  token1Price_in: [BigDecimal!]
  token1Price_not_in: [BigDecimal!]
  sqrtPriceX96: BigInt
  sqrtPriceX96_not: BigInt
  sqrtPriceX96_gt: BigInt
  sqrtPriceX96_lt: BigInt
  sqrtPriceX96_gte: BigInt
  sqrtPriceX96_lte: BigInt
  sqrtPriceX96_in: [BigInt!]
  sqrtPriceX96_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Pool_filter]
  or: [Pool_filter]
}

enum Pool_orderBy {
  id
  token0
  token0__id
  token0__decimals
  token0__name
  token0__symbol
  token0__type
  token1
  token1__id
  token1__decimals
  token1__name
  token1__symbol
  token1__type
  longShortToken
  longShortToken__id
  collateralToken
  collateralToken__id
  collateralToken__allowed
  collateralTokenPosition
  token0Price
  token1Price
  sqrtPriceX96
  createdAtTimestamp
  createdAtBlockNumber
}

type Position {
  """
  template: {USER_ADDRESS}-{LONG_SHORT_TOKEN_ADDRESS}}
  """
  id: ID!

  """
  average cost per token - for PNL calculation
  """
  costBasis: BigDecimal!

  """
  address who owned this position
  """
  ownerAddress: String!

  """
  token of which this position is tracking
  """
  longShortToken: LongShortToken!
}

input Position_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  costBasis: BigDecimal
  costBasis_not: BigDecimal
  costBasis_gt: BigDecimal
  costBasis_lt: BigDecimal
  costBasis_gte: BigDecimal
  costBasis_lte: BigDecimal
  costBasis_in: [BigDecimal!]
  costBasis_not_in: [BigDecimal!]
  ownerAddress: String
  ownerAddress_not: String
  ownerAddress_gt: String
  ownerAddress_lt: String
  ownerAddress_gte: String
  ownerAddress_lte: String
  ownerAddress_in: [String!]
  ownerAddress_not_in: [String!]
  ownerAddress_contains: String
  ownerAddress_contains_nocase: String
  ownerAddress_not_contains: String
  ownerAddress_not_contains_nocase: String
  ownerAddress_starts_with: String
  ownerAddress_starts_with_nocase: String
  ownerAddress_not_starts_with: String
  ownerAddress_not_starts_with_nocase: String
  ownerAddress_ends_with: String
  ownerAddress_ends_with_nocase: String
  ownerAddress_not_ends_with: String
  ownerAddress_not_ends_with_nocase: String
  longShortToken: String
  longShortToken_not: String
  longShortToken_gt: String
  longShortToken_lt: String
  longShortToken_gte: String
  longShortToken_lte: String
  longShortToken_in: [String!]
  longShortToken_not_in: [String!]
  longShortToken_contains: String
  longShortToken_contains_nocase: String
  longShortToken_not_contains: String
  longShortToken_not_contains_nocase: String
  longShortToken_starts_with: String
  longShortToken_starts_with_nocase: String
  longShortToken_not_starts_with: String
  longShortToken_not_starts_with_nocase: String
  longShortToken_ends_with: String
  longShortToken_ends_with_nocase: String
  longShortToken_not_ends_with: String
  longShortToken_not_ends_with_nocase: String
  longShortToken_: LongShortToken_filter

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Position_filter]
  or: [Position_filter]
}

enum Position_orderBy {
  id
  costBasis
  ownerAddress
  longShortToken
  longShortToken__id
}

type Query {
  longShortToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LongShortToken
  longShortTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LongShortToken_orderBy
    orderDirection: OrderDirection
    where: LongShortToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LongShortToken!]!
  market(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(
    skip: Int = 0
    first: Int = 100
    orderBy: Market_orderBy
    orderDirection: OrderDirection
    where: Market_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  pool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  collateralToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralToken
  collateralTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralToken_orderBy
    orderDirection: OrderDirection
    where: CollateralToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralToken!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  position(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positions(
    skip: Int = 0
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    where: Position_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Position!]!

  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type Subscription {
  longShortToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LongShortToken
  longShortTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LongShortToken_orderBy
    orderDirection: OrderDirection
    where: LongShortToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LongShortToken!]!
  market(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(
    skip: Int = 0
    first: Int = 100
    orderBy: Market_orderBy
    orderDirection: OrderDirection
    where: Market_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  pool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  collateralToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralToken
  collateralTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralToken_orderBy
    orderDirection: OrderDirection
    where: CollateralToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralToken!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  position(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positions(
    skip: Int = 0
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    where: Position_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Position!]!

  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

type Token {
  """
  address of token contract
  """
  id: ID!

  """
  decimals of token
  """
  decimals: BigInt!

  """
  name of token
  """
  name: String!

  """
  symbol of token
  """
  symbol: String!

  """
  e.g. Long, Short, Collateral, CollateralBase
  """
  type: String!
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  type: String
  type_not: String
  type_gt: String
  type_lt: String
  type_gte: String
  type_lte: String
  type_in: [String!]
  type_not_in: [String!]
  type_contains: String
  type_contains_nocase: String
  type_not_contains: String
  type_not_contains_nocase: String
  type_starts_with: String
  type_starts_with_nocase: String
  type_not_starts_with: String
  type_not_starts_with_nocase: String
  type_ends_with: String
  type_ends_with_nocase: String
  type_not_ends_with: String
  type_not_ends_with_nocase: String

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  decimals
  name
  symbol
  type
}

type Transaction {
  """
  template: {ACTION}-{OWNER_ADDRESS}-{TRANSACTION_HASH}-{LOG_INDEX}
  """
  id: ID!

  """
  actions we recognized (e.g. send, open, close, receive)
  """
  action: String!

  """
  token amount in ETH value (the amount to show on portfolio page UI)
  """
  amount: BigInt!

  """
  fee amount
  """
  fee: BigInt

  """
  the contract that emitted this event
  """
  contractAddress: String!

  """
  address of token this transaction is associated with
  """
  tokenAddress: String!

  """
  block number
  """
  createdAtBlockNumber: BigInt!

  """
  when transaction was made
  """
  createdAtTimestamp: BigInt!

  """
  transaction hash
  """
  hash: String!

  """
  owner
  """
  ownerAddress: String!

  """
  rate to ETH at tx time
  """
  rateToEth: BigInt!
}

input Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  action: String
  action_not: String
  action_gt: String
  action_lt: String
  action_gte: String
  action_lte: String
  action_in: [String!]
  action_not_in: [String!]
  action_contains: String
  action_contains_nocase: String
  action_not_contains: String
  action_not_contains_nocase: String
  action_starts_with: String
  action_starts_with_nocase: String
  action_not_starts_with: String
  action_not_starts_with_nocase: String
  action_ends_with: String
  action_ends_with_nocase: String
  action_not_ends_with: String
  action_not_ends_with_nocase: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  contractAddress: String
  contractAddress_not: String
  contractAddress_gt: String
  contractAddress_lt: String
  contractAddress_gte: String
  contractAddress_lte: String
  contractAddress_in: [String!]
  contractAddress_not_in: [String!]
  contractAddress_contains: String
  contractAddress_contains_nocase: String
  contractAddress_not_contains: String
  contractAddress_not_contains_nocase: String
  contractAddress_starts_with: String
  contractAddress_starts_with_nocase: String
  contractAddress_not_starts_with: String
  contractAddress_not_starts_with_nocase: String
  contractAddress_ends_with: String
  contractAddress_ends_with_nocase: String
  contractAddress_not_ends_with: String
  contractAddress_not_ends_with_nocase: String
  tokenAddress: String
  tokenAddress_not: String
  tokenAddress_gt: String
  tokenAddress_lt: String
  tokenAddress_gte: String
  tokenAddress_lte: String
  tokenAddress_in: [String!]
  tokenAddress_not_in: [String!]
  tokenAddress_contains: String
  tokenAddress_contains_nocase: String
  tokenAddress_not_contains: String
  tokenAddress_not_contains_nocase: String
  tokenAddress_starts_with: String
  tokenAddress_starts_with_nocase: String
  tokenAddress_not_starts_with: String
  tokenAddress_not_starts_with_nocase: String
  tokenAddress_ends_with: String
  tokenAddress_ends_with_nocase: String
  tokenAddress_not_ends_with: String
  tokenAddress_not_ends_with_nocase: String
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  hash: String
  hash_not: String
  hash_gt: String
  hash_lt: String
  hash_gte: String
  hash_lte: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_contains: String
  hash_contains_nocase: String
  hash_not_contains: String
  hash_not_contains_nocase: String
  hash_starts_with: String
  hash_starts_with_nocase: String
  hash_not_starts_with: String
  hash_not_starts_with_nocase: String
  hash_ends_with: String
  hash_ends_with_nocase: String
  hash_not_ends_with: String
  hash_not_ends_with_nocase: String
  ownerAddress: String
  ownerAddress_not: String
  ownerAddress_gt: String
  ownerAddress_lt: String
  ownerAddress_gte: String
  ownerAddress_lte: String
  ownerAddress_in: [String!]
  ownerAddress_not_in: [String!]
  ownerAddress_contains: String
  ownerAddress_contains_nocase: String
  ownerAddress_not_contains: String
  ownerAddress_not_contains_nocase: String
  ownerAddress_starts_with: String
  ownerAddress_starts_with_nocase: String
  ownerAddress_not_starts_with: String
  ownerAddress_not_starts_with_nocase: String
  ownerAddress_ends_with: String
  ownerAddress_ends_with_nocase: String
  ownerAddress_not_ends_with: String
  ownerAddress_not_ends_with_nocase: String
  rateToEth: BigInt
  rateToEth_not: BigInt
  rateToEth_gt: BigInt
  rateToEth_lt: BigInt
  rateToEth_gte: BigInt
  rateToEth_lte: BigInt
  rateToEth_in: [BigInt!]
  rateToEth_not_in: [BigInt!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  or: [Transaction_filter]
}

enum Transaction_orderBy {
  id
  action
  amount
  fee
  contractAddress
  tokenAddress
  createdAtBlockNumber
  createdAtTimestamp
  hash
  ownerAddress
  rateToEth
}
